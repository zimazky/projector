# Архитектурный обзор и предложения по улучшению для Projector

## Введение

Этот документ содержит архитектурный обзор веб-приложения Projector, акцентируя внимание на его текущих паттернах проектирования, сильных сторонах и областях для улучшения с точки зрения современных подходов к разработке приложений. Projector — это React-приложение, созданное с использованием TypeScript и MobX, предназначенное для планирования событий и ресурсов.

## Анализ текущей архитектуры

Приложение использует **MobX-центрированную архитектуру** с четким разделением ответственности на уровне каталогов (`1-app`, `3-pages`, `4-widgets`, `5-features`, `6-entities`, `7-shared`), что напоминает **архитектуру, основанную на срезах функций (feature-sliced design)**.

### Сильные стороны:

1.  **Четкая структура каталогов:** Нумерованная, многослойная структура каталогов (`1-app` для точки входа приложения, `3-pages` для основных представлений, `6-entities` для доменных моделей/хранилищ, `7-shared` для повторно используемых утилит) обеспечивает хорошую базовую организацию.
2.  **MobX для управления состоянием:** MobX — это мощная и высокопроизводительная библиотека управления состоянием, упрощающая реактивность. Ее использование последовательно во всем приложении.
3.  **TypeScript:** Использование TypeScript повышает качество кода, удобство сопровождения и опыт разработчика за счет статической проверки типов.
4.  **Webpack для сборки:** Webpack — это надежный сборщик модулей, эффективно настроенный с помощью `ts-loader` и `css-loader` для обработки TypeScript и CSS Modules.

### Области для улучшения:

1.  **Анти-паттерн "God Store" (`MainStore`):**
    *   **Проблема:** `MainStore` (и, соответственно, `src/6-entities/stores/MainStore.ts`) выступает в роли центрального оркестратора, напрямую управляя ссылками почти на все другие хранилища (`ProjectsStore`, `EventsStore`, `EventsCache`, `WeatherStore`, `CalendarStore`, `DayListStore`, `EventFormStore`). Он также обрабатывает прямое взаимодействие с `localStorage`, интеграцию с внешними службами Google API (`GAPI`) и `RemoteStorage`, логику синхронизации данных и даже некоторое специфическое для пользовательского интерфейса состояние (`viewMode`, `isMenuOpen`).
    *   **Последствия:** Это создает сильно связанное, монолитное хранилище, которое трудно тестировать изолированно, понимать и поддерживать. Ответственность между логикой приложения, сохранением данных и проблемами пользовательского интерфейса размыта.
2.  **Глобальные синглтоны для хранилищ:**
    *   **Проблема:** Все хранилища инстанцируются как глобальные синглтоны (`export const mainStore = new MainStore(...)`). Хотя это удобно для доступа, такой подход скрывает зависимости, затрудняет тестирование отдельных компонентов/хранилищ (из-за фиксированных экземпляров) и может привести к неожиданным побочным эффектам.
3.  **Ручные обходные пути для реактивности (`forceUpdate`, `useUpdate`, `mustForceUpdate`):**
    *   **Проблема:** Повторное использование `useUpdate` и `mainStore.mustForceUpdate` для принудительного перерисовки компонентов предполагает, что автоматическая реактивность MobX, возможно, не полностью используется, или что определенные сценарии требуют ручного вмешательства. Это может указывать на базовую проблему с отслеживанием наблюдаемых изменений или логикой рендеринга компонентов.
4.  **Прямое манипулирование DOM в компонентах:**
    *   **Проблема:** Компоненты, такие как `Calendar.tsx`, напрямую взаимодействуют с DOM с помощью `document.getElementById` для прокрутки.
    *   **Последствия:** Это связывает компоненты React с императивными API DOM, что затрудняет их тестирование, делает их менее декларативными и потенциально менее производительными, чем идиоматические паттерны React (например, использование `useRef` для ссылок на DOM).
5.  **Базовая обработка ошибок:**
    *   **Проблема:** Обработка ошибок в основном основана на вызовах `alert()` (например, в `MainStore` для ошибок сохранения/загрузки).
    *   **Последствия:** `alert()` обеспечивает плохой пользовательский опыт, прерывает рабочий процесс и не подходит для производственных приложений. Отсутствует централизованный, удобный для пользователя механизм обратной связи об ошибках.
6.  **Тесная связь с внешними службами:**
    *   **Проблема:** `MainStore` напрямую импортирует и использует `GAPI` и `RemoteStorage`.
    *   **Последствия:** Это затрудняет замену или имитацию этих служб для тестирования или внедрение альтернативных источников данных без изменения `MainStore`.
7.  **Устаревший паттерн выборки/кэширования данных:**
    *   **Проблема:** `EventsCache` и логика ручной синхронизации в `MainStore` обрабатывают кэширование и сохранение данных.
    *   **Последствия:** Хотя этот подход функционален, ему часто не хватает современных функций, таких как автоматическая ревалидация, оптимистические обновления и встроенные состояния загрузки/ошибки, предоставляемые специализированными библиотеками.

## Предложения по улучшению

### 1. Декомпозиция "God Store" (`MainStore`)

*   **Действие:** Рефакторинг `MainStore` на более мелкие, сфокусированные единицы.
*   **Рекомендация:**
    *   **Оркестратор корневого приложения (облегченный `MainStore`):** Это облегченное хранилище будет в основном координировать действия между другими доменными хранилищами и службами, не содержа напрямую бизнес-логику или состояние пользовательского интерфейса.
    *   **Хранилище состояния пользовательского интерфейса:** Создайте выделенное `UIStore` (или используйте React Context) для управления специфичным для пользовательского интерфейса состоянием, таким как `viewMode`, `isMenuOpen`, видимость модальных окон и т. д. Это отделяет презентационные concerns от бизнес-логики.
    *   **Служба сохранения/синхронизации данных:** Извлеките `saveToLocalStorage`, `saveToGoogleDrive`, `loadFromGoogleDrive` в автономную службу (например, `DataSyncService` или `StorageService`). Эта служба будет отвечать исключительно за чтение/запись данных в различные хранилища.
    *   **Абстракция уровня служб:** Оберните `GAPI` и `RemoteStorage` в интерфейсы или абстрактные классы, а затем внедряйте конкретные реализации в `DataSyncService` или другие соответствующие хранилища/службы. Это упрощает имитацию и замену внешних служб.
*   **Преимущества:** Улучшенное разделение ответственности, лучшая тестируемость, снижение сложности, повышенное удобство сопровождения.

### 2. Модернизация выборки и кэширования данных

*   **Действие:** Внедрение современной библиотеки для выборки данных.
*   **Рекомендация:** Интегрируйте библиотеку, такую как **React Query (TanStack Query)** или **SWR**.
    *   Эти библиотеки предоставляют мощные хуки для выборки, кэширования, синхронизации и обновления асинхронных данных в React. Они обрабатывают состояния загрузки, обработку ошибок, фоновое повторное получение, оптимистические обновления и сборку мусора "из коробки".
    *   Это может заменить большую часть логики ручного кэширования в `EventsCache` и оптимизировать синхронизацию данных в `MainStore`.
*   **Преимущества:** Упрощенное управление асинхронными данными, улучшенный пользовательский опыт с автоматическим обновлением пользовательского интерфейса, сокращение шаблонного кода, лучшая обработка ошибок и встроенные оптимизации производительности.

### 3. Внедрение явного внедрения зависимостей

*   **Действие:** Отказ от глобальных синглтонов для хранилищ в пользу явного управления зависимостями.
*   **Рекомендация:**
    *   **React Context для хранилищ:** Для хранилищ, к которым необходимо обращаться многим компонентам, предоставьте их через React Context. Это делает зависимости явными и тестируемыми, позволяя предоставлять различные экземпляры хранилищ во время тестирования.
    *   **Внедрение через конструктор:** При создании экземпляров хранилищ передавайте их зависимости (другие хранилища или службы) через их конструкторы.
    *   **Контейнер/реестр (необязательно):** Для более крупных приложений простой контейнер внедрения зависимостей или реестр может управлять экземплярами хранилищ, но React Context часто достаточен для большинства зависимостей, связанных с пользовательским интерфейсом.
*   **Преимущества:** Повышенная тестируемость, более четкий граф зависимостей, простота рефакторинга, более гибкая архитектура.

### 4. Улучшение обработки ошибок

*   **Действие:** Замена `alert()` на удобный для пользователя и последовательный механизм обратной связи об ошибках.
*   **Рекомендация:**
    *   **Toast-уведомления:** Внедрите систему toast-уведомлений (например, с использованием библиотеки `react-toastify` или пользовательского решения) для отображения неблокирующих сообщений об ошибках, успешных операциях и информации.
    *   **Глобальные границы ошибок (Error Boundaries):** Используйте React Error Boundaries для корректной обработки ошибок рендеринга в частях пользовательского интерфейса, предотвращая крах всего приложения.
    *   **Централизованное логирование ошибок:** Рассмотрите возможность интеграции глобальной службы логирования ошибок (например, Sentry, LogRocket) для производственных сред.
*   **Преимущества:** Улучшенный пользовательский опыт, централизованное управление ошибками, лучшая отладка в производстве.

### 5. Улучшение идиом React и композиции компонентов

*   **Действие:** Рефакторинг компонентов, чтобы они были более декларативными и менее зависимыми от прямого манипулирования DOM.
*   **Рекомендация:**
    *   **`useRef` для ссылок на DOM:** Используйте хук React `useRef` для доступа к элементам DOM, когда это необходимо, а не `document.getElementById`.
    *   **Пользовательские хуки для сложной логики:** Извлеките сложную логику пользовательского интерфейса (например, логику `onScrollHandle` в `Calendar.tsx`, оркестрацию перетаскивания) в пользовательские хуки. Это сохраняет компоненты чистыми, повторно используемыми и тестируемыми.
    *   **Исследование `forceUpdate`:** Тщательно изучите варианты использования, требующие `forceUpdate`. Реактивность MobX в идеале должна охватывать большинство сценариев. В противном случае рассмотрите возможность реструктуризации наблюдаемых или границ компонентов.
*   **Преимущества:** Более чистые, более удобные для сопровождения и более тестируемые компоненты; соблюдение лучших практик React.

### 6. Рассмотрение библиотеки компонентов или дизайн-системы

*   **Действие:** Оцените существующие компоненты `7-shared/ui`.
*   **Рекомендация:** Хотя присутствует пользовательская библиотека пользовательского интерфейса, для более быстрой разработки и единообразного дизайна рассмотрите возможность внедрения или интеграции с хорошо поддерживаемой библиотекой компонентов (например, Material UI, Ant Design, Chakra UI). Если вы придерживаетесь пользовательских компонентов, убедитесь, что они тщательно протестированы и задокументированы.
*   **Преимущества:** Единообразный пользовательский интерфейс/UX, более быстрая разработка, встроенные функции доступности, потенциально снижение затрат на обслуживание.

## Заключение

Приложение Projector имеет прочную основу с React, TypeScript и MobX, а также хорошо продуманную структуру папок. Однако оно может значительно выиграть от модернизации паттернов управления состоянием, в частности, за счет декомпозиции монолитного `MainStore`, внедрения явного внедрения зависимостей и использования современных решений для выборки данных. Эти изменения приведут к созданию более модульного, тестируемого, удобного для сопровождения и масштабируемого приложения.