# Анализ и план рефакторинга для поддержки нескольких счетов и единиц измерения

## 1. Текущая ситуация

Приложение в настоящее время поддерживает один, подразумеваемый счет для каждого события. Это представлено свойствами `credit` и `debit` в `EventDto`, `IEventModel`, `SingleEventModel` и `RepeatableEventModel`. Расчеты баланса в `EventsCache` также предполагают единый баланс (`actualBalance`, `plannedBalance`) и не учитывают разные единицы измерения.

## 2. Основная проблема

Структура `credit: number` и `debit: number` недостаточна для отслеживания движений по нескольким счетам с разными единицами измерения (например, рубли, доллары, литры). Она не может представить перевод (списание со счета А, зачисление на счет Б) в рамках одного события и не может обрабатывать события, затрагивающие более двух счетов.

## 3. Ключевые файлы для рефакторинга

*   **Структуры данных:**
    *   `EventDto.ts`: Требуется изменить для поддержки операций по нескольким счетам.
    *   `IEventModel.ts`, `SingleEventModel.ts`, `RepeatableEventModel.ts`: Внутренние модели домена должны быть обновлены.
    *   `EventCacheStructure.ts`: Кешированное представление событий также нуждается в обновлении.
*   **Бизнес-логика:**
    *   `EventsStore.ts` и менеджеры: Логика создания и обновления событий изменится.
    *   `EventMappers.ts`: Мапперы должны будут преобразовывать между новыми структурами DTO и модели.
*   **UI:**
    *   `EventForm.tsx`: Форма для создания/редактирования событий требует значительных изменений для управления движениями по нескольким счетам и их единицами измерения.
*   **Расчеты:**
    *   `EventsCache.ts`: Логика расчета баланса требует полной переработки для вычисления и кеширования балансов по каждому счету с учетом их единиц измерения.
*   **Управление счетами:**
    *   `7-shared/model/accounts/Accounts.ts`: Этот файл уже представляет хорошую основу с классами `Account`, `AccountOperation` и `Accounts` для управления списком счетов и расчета балансов. Он уже поддерживает `unit` (единицу измерения) для каждого счета, что будет использовано в рефакторинге.

## 4. Предлагаемая новая структура данных

Вместо `credit` и `debit` я предлагаю добавить свойство `movements` в модели событий. Это свойство будет массивом объектов, где каждый объект представляет операцию по одному счету. Единица измерения будет браться из свойств счета.

```typescript
// Предлагаемая структура для EventDto и EventModel
export type AccountMovement = {
  account: string; // Имя счета
  amount: number;  // Положительное значение для зачисления, отрицательное для списания
}

// В EventDto.ts
export type EventDto = {
  // ... другие поля
  movements?: AccountMovement[];
  // credit и debit будут удалены
}

// В IEventModel.ts, SingleEventModel.ts, RepeatableEventModel.ts
export type IEventModel = {
  // ... другие поля
  movements: AccountMovement[];
  // credit и debit будут удалены
}
```

Эта структура является гибкой и может представлять:
*   **Доход:** `[{ account: 'Кошелек', amount: 100 }]`
*   **Расход:** `[{ account: 'Кошелек', amount: -50 }]`
*   **Перевод:** `[{ account: 'Банк', amount: -100 }, { account: 'Кошелек', amount: 100 }]`

## План рефакторинга

### Фаза 1: Модель данных и минимально жизнеспособный UI

*   **Шаг 1: Обновить модели данных.**
    *   В `EventDto.ts`, `IEventModel.ts`, `SingleEventModel.ts` и `RepeatableEventModel.ts` удалить свойства `credit` и `debit` и добавить `movements: AccountMovement[]`. В `EventDto` это свойство может быть опциональным.
    *   Определить тип `AccountMovement` в `src/7-shared/model/accounts/Accounts.ts` или в новом файле, чтобы он был доступен глобально.

*   **Шаг 2: Обновить мапперы.**
    *   В `EventMappers.ts` обновить функции `eventDtoToIEventModel`, `singleEventModelToEventDto` и `repeatableEventModelToEventDto` для обработки нового поля `movements`.

*   **Шаг 3: Обновить UI (`EventForm.tsx`) - простое внедрение.**
    *   На данный момент, чтобы избежать сложных изменений в UI, поля `credit` и `debit` можно заменить одним `TextArea` для `movements`.
    *   Пользователь будет вводить движения в виде простого текста, например, одно движение на строку, как `Кошелек (RUB): -100` или `Бензин (Л): 10`.
    *   Вспомогательная функция будет парсить этот текст в массив `AccountMovement[]` при отправке формы. При парсинге она будет использовать `Accounts.addAccount(name, unit)` для добавления новых счетов с указанием единицы измерения.
    *   Это временное решение, чтобы система оставалась работоспособной до создания более дружественного пользовательского интерфейса для движений.

*   **Шаг 4: Обновить хранилища.**
    *   В `SingleEventManager.ts` и `RepeatableEventManager.ts` обновить логику `add` и `update` для обработки массива `movements` вместо `credit`/`debit`.

*   **Шаг 5: Временно отключить расчет баланса.**
    *   Логика расчета баланса в `EventsCache.ts` будет нарушена. Я закомментирую ее или сделаю так, чтобы она возвращала 0, чтобы приложение могло собираться и запускаться. Полная реализация расчета баланса для нескольких счетов будет во второй фазе.

### Фаза 2: Полный расчет баланса и UI

*   **Шаг 6: Переработать расчеты баланса (`EventsCache.ts`).**
    *   Изменить `cachedActualBalance` и `cachedPlannedBalance` с `number[]` на структуру, которая может хранить балансы для нескольких счетов, например, `{[timestamp]: AccountBalance[]}`.
    *   Переписать `calculateActualBalance`, `getActualBalance` и `getPlannedBalance` для использования хелпера `Accounts.executeOperations`. Они должны корректно обрабатывать `movements` из каждого события.
    *   Логика **не должна** суммировать балансы с разными единицами измерения.
    *   UI, отображающий балансы (`CalendarDay.tsx`), нужно будет обновить, чтобы показывать балансы, сгруппированные по единицам измерения (например, итого по RUB, итого по USD и т.д.), используя `Accounts.getGroupedBalance`.

*   **Шаг 7: Улучшить UI (`EventForm.tsx`).**
    *   Заменить временный `TextArea` на динамическую секцию формы, где пользователи смогут добавлять/удалять движения по счетам.
    *   Каждая строка движения должна иметь:
        *   Выпадающий список для выбора существующего счета.
        *   Поле для ввода суммы.
        *   Отображение единицы измерения для выбранного счета (нередактируемое).
    *   Реализовать возможность создания нового счета с указанием его единицы измерения прямо из формы.

Этот план разбивает сложный рефакторинг на управляемые фазы, начиная с модели данных и минимального UI для обеспечения работоспособности системы, а затем переходя к более сложным функциям, таким как расчеты баланса и отполированный UI.