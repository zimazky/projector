# План декомпозиции "God Store" (`MainStore`)

## Введение

Этот документ описывает пошаговый план по декомпозиции монолитного "God Store" (`MainStore`) в приложении Projector. Целью является улучшение модульности, тестируемости, понятности и удобства сопровождения кода за счет четкого разделения ответственности.

## 1. Текущие обязанности `MainStore` (краткое напоминание)

На данный момент `MainStore` выполняет следующие функции:
*   Координация других дочерних хранилищ (`ProjectsStore`, `EventsStore`, `EventsCache`, `WeatherStore`, `CalendarStore`, `DayListStore`, `EventFormStore`).
*   Взаимодействие с `localStorage`.
*   Интеграция с Google API (`GAPI`) и сервисом удаленного хранилища (`RemoteStorage`).
*   Логика синхронизации данных (сохранение/загрузка в локальное хранилище и Google Drive).
*   Управление состоянием пользовательского интерфейса (`viewMode`, `isMenuOpen`).
*   Механизм принудительного обновления (`mustForceUpdate`).

## 2. Новые модули и сервисы

Для разделения ответственности предлагается ввести следующие новые модули/сервисы:

*   **Облегченный `MainStore` (Application Root Orchestrator):** Будет выполнять функции координатора, но не содержать сложную бизнес-логику или состояние UI.
*   **`UIStore`:** Специализированное хранилище для управления состоянием пользовательского интерфейса (`viewMode`, `isMenuOpen`, состояние модальных окон, уведомлений и т.д.).
*   **`StorageService` (или `DataSyncService`):** Сервис для абстрагирования механизмов сохранения и загрузки данных. Будет отвечать за взаимодействие с `localStorage` и `RemoteStorage` (Google Drive).
*   **`GoogleApiService` (или `AuthService`):** Сервис для инкапсуляции всей логики взаимодействия с Google API, включая инициализацию, авторизацию и выход из системы.
*   **Рефакторинг `RemoteStorage`:** Убедиться, что `RemoteStorage` представляет собой чистый уровень доступа к данным для Google Drive, не смешивая его с логикой синхронизации или авторизации.

## 3. Пошаговый план реализации

### Шаг 0: Подготовка

*   **Создание ветки:** Создать новую ветку для этих изменений (например, `feature/decompose-main-store`).
*   **Тестовое покрытие:** Убедиться, что существующее тестовое покрытие достаточно или добавить базовые тесты для критически важных частей `MainStore`, которые будут рефакториться. Если тестов нет, рассмотреть возможность добавления интеграционных тестов для проверки поведения системы в целом после изменений.
*   **Понимание зависимостей:** Тщательно проанализировать все места, где используются `MainStore` и его дочерние хранилища, чтобы предвидеть каскадные изменения.

### Шаг 1: Извлечение состояния пользовательского интерфейса (`UIStore`)

*   **Действие:** Перенести все UI-специфичное состояние и логику из `MainStore` в новый `UIStore`.
*   **Подробности:**
    *   Создать файл `src/6-entities/stores/UIStore/UIStore.ts`.
    *   Перенести свойства `viewMode` и `isMenuOpen`, а также методы `changeViewMode` и `toggleMenu` в `UIStore`.
    *   Инстанцировать `UIStore` как синглтон (пока что) и сделать его доступным в соответствующих компонентах (например, `App.tsx`, `Header.tsx`).
    *   Обновить компоненты, которые ранее обращались к `mainStore.viewMode` или `mainStore.isMenuOpen`, чтобы они использовали `uiStore`.
*   **Проверка:** Убедиться, что UI функционирует корректно, переключение режимов и открытие/закрытие меню работают.

### Шаг 2: Извлечение интеграции с Google API (`GoogleApiService`)

*   **Действие:** Создать отдельный сервис для всей логики взаимодействия с Google API.
*   **Подробности:**
    *   Создать файл `src/7-shared/services/GoogleApiService.ts`.
    *   Перенести логику инициализации `GAPI` (`GAPI.init`), методы `logIn`, `logOut`, `isLoggedIn` в `GoogleApiService`.
    *   `GoogleApiService` будет инкапсулировать `GAPI` и его callbacks.
    *   Обновить `MainStore.gapiInit`, `logIn`, `logOut` таким образом, чтобы они вызывали соответствующие методы `GoogleApiService`. `MainStore` теперь будет зависеть от `GoogleApiService` через внедрение зависимости (см. Шаг 6).
    *   `MainStore` будет слушать изменения статуса авторизации через подписку или callbacks от `GoogleApiService`.
*   **Проверка:** Убедиться, что авторизация/деавторизация в Google работает, и приложение правильно реагирует на статус входа.

### Шаг 3: Извлечение логики синхронизации данных (`StorageService`)

*   **Действие:** Создать сервис, который абстрагирует операции сохранения и загрузки данных, будь то в `localStorage` или Google Drive.
*   **Подробности:**
    *   Создать файл `src/7-shared/services/StorageService.ts`.
    *   Перенести логику `saveToLocalStorage`, `saveToGoogleDrive`, `loadFromGoogleDrive` из `MainStore` в `StorageService`.
    *   `StorageService` будет получать необходимые данные для сохранения (например, `ProjectData[]` и `EventsStoreData`) в качестве параметров.
    *   `StorageService` будет зависеть от `GoogleApiService` (для Google Drive) и `RemoteStorage`.
    *   Обновить `MainStore` так, чтобы его методы сохранения/загрузки вызывали `StorageService`. `MainStore` будет передавать данные, полученные от `projectsStore` и `eventsStore`, в `StorageService`.
    *   Состояние `isSyncWithLocalstorage` и `isSyncWithGoogleDrive` может быть перенесено в `StorageService` или в облегченный `MainStore`, если оно необходимо для общего состояния приложения.
*   **Проверка:** Убедиться, что сохранение и загрузка данных из обоих источников работают корректно.

### Шаг 4: Устранение механизма `mustForceUpdate`

*   **Действие:** Идентифицировать и устранить причины, по которым требуется принудительное обновление компонентов.
*   **Подробности:**
    *   Тщательно проанализировать все места использования `useUpdate` и `mainStore.mustForceUpdate`.
    *   В большинстве случаев `forceUpdate` указывает на то, что компоненты не реагируют на изменения наблюдаемых данных должным образом, или что изменения происходят вне наблюдаемых контекстов MobX.
    *   Возможные решения:
        *   Убедиться, что все изменяемые данные являются `observable` или находятся внутри `@action` (для классов MobX).
        *   Использовать более гранулированные наблюдаемые (например, наблюдаемый объект вместо переназначения пустого объекта).
        *   Реструктурировать компоненты, чтобы они реагировали на конкретные изменения в MobX-хранилищах, а не на глобальный флаг принудительного обновления.
*   **Проверка:** Удалить все вызовы `forceUpdate` и `useUpdate` и убедиться, что приложение обновляется корректно.

### Шаг 5: Облегчение `MainStore`

*   **Действие:** После всех предыдущих шагов `MainStore` должен стать значительно меньше и сфокусироваться исключительно на координации.
*   **Подробности:**
    *   Удалить из `MainStore` всю извлеченную логику.
    *   `MainStore` теперь будет содержать ссылки на `UIStore`, `StorageService`, `GoogleApiService` и другие доменные хранилища.
    *   Метод `init` в `MainStore` будет оркестрировать инициализацию этих новых сервисов и хранилищ.
*   **Проверка:** Провести ревью кода `MainStore`, чтобы убедиться, что он не содержит лишней логики.

### Шаг 6: Внедрение явного внедрения зависимостей

*   **Действие:** Пересмотреть, как хранилища и сервисы получают свои зависимости, переходя от глобальных синглтонов к явному внедрению зависимостей.
*   **Подробности:**
    *   **Внедрение через конструктор:** Для всех хранилищ и сервисов, которые зависят от других, передавать эти зависимости через конструктор. Например, `new MainStore(uiStore, storageService, googleApiService, projectsStore, eventsStore, eventsCache)`.
    *   **React Context для хранилищ:** Вместо импорта глобальных синглтонов хранилищ в каждом компоненте, можно создать React Context для предоставления экземпляров хранилищ (или корня MobX-хранилища) компонентам глубоко в дереве. Это делает зависимости более явными и позволяет легко менять экземпляры хранилищ для тестирования.
    *   **Централизованная инстанциация:** Создать один центральный файл (например, `src/root.ts` или `src/main.ts`), где все хранилища и сервисы будут инстанцироваться с правильными зависимостями и затем экспортироваться (возможно, как единый объект корневого хранилища).
*   **Проверка:** Убедиться, что все зависимости явно передаются, и ни один компонент не импортирует глобальный синглтон, если его можно получить через контекст или пропсы.

## Преимущества реализации плана

*   **Улучшенная модульность:** Каждый модуль/сервис имеет четко определенную и ограниченную ответственность.
*   **Повышенная тестируемость:** Компоненты и сервисы легче тестировать изолированно, поскольку их зависимости могут быть легко замокированы (mocked) или подменены (stubbed).
*   **Снижение сложности:** Код становится легче читать и понимать, так как каждый файл делает только одну вещь.
*   **Улучшенное удобство сопровождения и масштабируемость:** Изменения в одном модуле с меньшей вероятностью повлияют на другие части системы. Добавление новых функций становится проще.
*   **Более гибкая архитектура:** Легче заменять или изменять реализации сервисов (например, перейти на другое облачное хранилище или другой механизм аутентификации).
*   **Лучшее соответствие идиомам React и MobX:** Использование MobX Observer для реактивности, а не ручных `forceUpdate`.

Этот план обеспечит поэтапный подход к улучшению архитектуры, минимизируя риски и позволяя проверять изменения на каждом шаге.
