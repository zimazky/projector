# Анализ и план реализации компонента выбора файлов Google Drive

## 1. Оценка возможности реализации

Реализация кастомного компонента выбора файлов с Google Drive является вполне осуществимой задачей, учитывая текущую архитектуру проекта (React, TypeScript, MobX, существующая интеграция с Google API).

### Ключевые аспекты и их осуществимость:

*   **Google Drive API:** Основным инструментом будет Google Drive API (v3). Функциональность для получения списка файлов и папок внутри определенного родительского каталога (с учетом иерархии) легко доступна через метод `files.list`.
    *   `q` параметр:
        *   `'parentId' in parents` для получения содержимого папки.
        *   `mimeType = 'application/vnd.google-apps.folder'` для фильтрации папок.
    *   `fields` параметр: Для получения необходимых метаданных, таких как `id`, `name`, `mimeType`, `parents`, `iconLink`, `webViewLink`.
*   **Аутентификация:** В проекте уже есть `src/shared/services/gapi.ts` и `src/shared/services/GoogleApiService.ts`, которые, вероятно, управляют аутентификацией и инициализацией Google API-клиента. Новый компонент должен использовать эти существующие сервисы для выполнения запросов к Google Drive API. Это значительно упрощает задачу, так как не потребуется реализовывать аутентификацию с нуля.
*   **Frontend Framework (React) и State Management (MobX):** Проект использует React и MobX, что идеально подходит для создания интерактивного UI с хорошо управляемым состоянием. Будет создан отдельный MobX-стор для управления состоянием файлового пикера (текущая папка, список элементов, состояние загрузки, выбранный файл).
*   **UI Library (Material UI):** Пользователь предложил использовать Material UI. Если в проекте его нет, это будет новая зависимость. Тем не менее, Material UI предоставляет готовые компоненты (Dialog, List, ListItem, Table, Button, CircularProgress) для быстрого построения функционального и эстетичного интерфейса. Альтернативно, можно использовать существующие компоненты из `src/shared/ui/` (Button, Dialog, List, ListItem, Modal, Spinner), если они достаточно гибки. Для простоты и соответствия предложению пользователя, если Material UI отсутствует, его добавление будет рассмотрено.
*   **Навигация по папкам:** Реализация навигации "вверх" ("..") требует отслеживания истории посещенных папок или хранения идентификаторов родителей для текущей папки. Навигация "вниз" будет осуществляться путем выполнения нового запроса `files.list` для выбранной папки.

### Потенциальные сложности:

*   **Обработка ошибок API:** Необходимо предусмотреть обработку ошибок при взаимодействии с Google Drive API (например, проблемы с сетью, ошибки аутентификации, превышение квот).
*   **Отображение большого количества элементов:** Если папка содержит очень много файлов/папок, может потребоваться реализация подгрузки по мере прокрутки (infinite scroll) или пагинации, чтобы избежать проблем с производительностью. Для первоначальной версии можно ограничиться отображением разумного количества элементов.
*   **UX/UI:** Обеспечение интуитивно понятного пользовательского опыта при навигации и выборе файлов.

## 2. Предлагаемый план реализации

Я предлагаю следующий пошаговый план реализации:

### Шаг 1: Исследование существующей интеграции Google API

*   Проанализировать файлы `src/shared/services/gapi.ts` и `src/shared/services/GoogleApiService.ts` для понимания механизмов инициализации клиента GAPI, аутентификации и выполнения запросов.
*   Определить, как можно использовать `GoogleApiService` для выполнения запросов к Google Drive API.

### Шаг 2: Создание MobX Store для файлового пикера

*   Создать новую папку `src/6-entities/stores/DrivePicker`.
*   Создать файл `src/6-entities/stores/DrivePicker/DrivePickerStore.ts`.
*   **Определить состояние (`state`) стора:**
    *   `currentFolderId: string | null` (ID текущей отображаемой папки, `root` для корневой).
    *   `currentPath: { id: string, name: string }[]` (Массив объектов для отображения "хлебных крошек" и навигации вверх).
    *   `items: DriveItem[]` (Массив объектов, представляющих файлы и папки в текущей папке).
    *   `isLoading: boolean` (Флаг состояния загрузки).
    *   `error: string | null` (Сообщение об ошибке, если есть).
    *   `selectedFile: DriveItem | null` (Выбранный файл).
*   **Определить действия (`actions`) стора:**
    *   `loadFolder(folderId: string)`: Асинхронное действие для загрузки содержимого папки с использованием Google Drive API.
    *   `navigateUp()`: Действие для перехода на уровень выше.
    *   `selectFile(file: DriveItem)`: Действие для выбора файла.
    *   `reset()`: Действие для сброса состояния пикера.
*   **Определить структуру `DriveItem`:**
    ```typescript
    interface DriveItem {
        id: string;
        name: string;
        mimeType: string; // 'application/vnd.google-apps.folder' для папок
        iconLink?: string; // Иконка, предоставляемая Google Drive
        webViewLink?: string; // Ссылка для просмотра файла/папки
        parents?: string[]; // Родительские папки
    }
    ```

### Шаг 3: Реализация компонента React DriveFilePicker

*   Создать новую папку `src/4-widgets/DriveFilePicker`.
*   Создать файл `src/4-widgets/DriveFilePicker/DriveFilePicker.tsx`.
*   Использовать `observer` из MobX-React для реакции на изменения в `DrivePickerStore`.
*   **Структура UI:**
    *   Использовать `Dialog` (из `src/shared/ui/Dialog` или Material UI) как контейнер для пикера.
    *   Отображать "хлебные крошки" для текущего пути.
    *   Элемент ".." для перехода на родительский уровень.
    *   Использовать `List` и `ListItem` (из `src/shared/ui/List` или Material UI) для отображения файлов и папок.
    *   Отображать иконки для различения файлов и папок (можно использовать `iconLink` из API или собственные иконки).
    *   Индикатор загрузки (`Spinner` из `src/shared/ui/Spinner` или Material UI).
    *   Кнопки "Выбрать" / "Отмена".
*   **Логика взаимодействия:**
    *   Обработчики кликов для папок (вызов `drivePickerStore.loadFolder(folderId)`).
    *   Обработчик клика для ".." (вызов `drivePickerStore.navigateUp()`).
    *   Обработчики кликов для файлов (вызов `drivePickerStore.selectFile(file)`).
    *   Пропсы для `onSelect(file: DriveItem)` и `onCancel()`.

### Шаг 4: Интеграция с Google Drive API в DrivePickerStore

*   В `DrivePickerStore.ts` реализовать асинхронные вызовы к Google Drive API через `GoogleApiService`.
*   Сформировать правильные `q` и `fields` параметры для `gapi.client.drive.files.list`.
    *   Пример `q` для корневой папки: `'root' in parents and trashed = false`
    *   Пример `q` для подпапки: `'${folderId}' in parents and trashed = false`
    *   Пример `fields`: `files(id, name, mimeType, parents, iconLink, webViewLink)`

### Шаг 5: Добавление стилей

*   Создать `src/4-widgets/DriveFilePicker/DriveFilePicker.module.css` для компонентно-специфичных стилей, следуя конвенциям CSS Modules.
*   Использовать стили Material UI, если эта библиотека будет добавлена.

### Шаг 6: Тестирование (опционально, но рекомендуется)

*   Написать юнит-тесты для `DrivePickerStore.ts` с использованием Jest (если он настроен) для проверки логики загрузки, навигации и обработки состояния. Мокнуть запросы к Google Drive API.
*   Написать интеграционные тесты для `DriveFilePicker.tsx` (если в проекте есть практика написания таких тестов, например, с использованием React Testing Library).

### Шаг 7: Использование компонента

*   После реализации, `DriveFilePicker` можно будет использовать в любом месте приложения, где требуется выбор файла с Google Drive, например, в `EventForm` или на странице настроек.

## Дополнительные соображения:

*   **Обработка "шаблонов" Google Drive:** Google Docs, Sheets и т.д. имеют специальные `mimeType`. Их следует отображать как обычные файлы.
*   **Права доступа:** Убедиться, что используемый `GoogleApiService` имеет необходимые права доступа (`scope`) для чтения файлов Google Drive.
*   **Локализация:** Обязательно предусмотреть локализацию для всех текстовых элементов пикера.
*   **Использование Material UI:** Material UI будет использоваться локально, только для компонента выбора файлов. Его интеграция будет осуществлена таким образом, чтобы не нарушать стили и логику существующих компонентов в проекте. Это может потребовать изоляции стилей или использования специфичных импортов, чтобы избежать конфликтов.

Этот план обеспечивает структурированный подход к разработке компонента, минимизируя риски и обеспечивая использование существующих проектных конвенций и сервисов.