# Анализ и рекомендации по рефакторингу компонента SaveToDrive

## 1. Обзор текущей реализации

Компонент `src/5-features/SaveToDrive/SaveToDrive.tsx` отвечает за функциональность сохранения файлов на Google Диск. В его состав входит не только основная логика выбора папки и сохранения файла, но и реализация диалога разрешения конфликтов имен файлов.

**Текущая структура диалога конфликтов:**
*   Диалог представлен компонентом `Dialog` из `src/7-shared/ui/Dialog/Dialog`.
*   Видимость диалога управляется флагом `saveToDriveStore.showConflictDialog`.
*   Отображает имя файла, вызывающего конфликт (`conflictingFileName`).
*   Предлагает пользователю действия: "Перезаписать", "Переименовать" (с полем ввода нового имени), "Подтвердить переименование" и "Отмена".
*   Логика обработки этих действий (`handleResolveConflict`) и обновления нового имени файла (`setNewFileNameForConflict`) находится в `saveToDriveStore`.
*   Состояние для отображения поля ввода нового имени (`showRenameInput`) управляется локально внутри компонента `SaveToDrive.tsx`.

## 2. Проблемы текущей реализации

Совмещение основной логики сохранения и диалога разрешения конфликтов в одном компоненте `SaveToDrive` приводит к следующим проблемам:
*   **Нарушение принципа единой ответственности (Single Responsibility Principle):** Компонент `SaveToDrive` выполняет две различные задачи — сохранение файла и разрешение конфликтов, что усложняет его понимание и поддержку.
*   **Снижение переиспользуемости:** Логика диалога конфликтов жестко привязана к `SaveToDrive`, что затрудняет ее повторное использование в других частях приложения, если возникнет подобная потребность.
*   **Усложнение компонента:** `SaveToDrive` содержит избыточный код, относящийся к диалогу конфликтов, что увеличивает его размер и сложность.

## 3. Рекомендации по рефакторингу с учетом FSD и современных подходов

Предлагается выделить логику разрешения конфликтов в отдельный, специализированный компонент. Это позволит улучшить модульность, читаемость и переиспользуемость кода.

### 3.1. Размещение нового компонента согласно FSD

Учитывая, что диалог разрешения конфликтов является специфическим сценарием внутри функции сохранения файла, и он включает в себя как UI, так и часть логики взаимодействия со стором, наиболее подходящим слоем для него будет **`5-features` (Фича)**. Он представляет собой законченную часть функциональности, решающую конкретную задачу — разрешение конфликта.

**Предлагаемая структура:**

```
src/
└── 5-features/
    └── FileConflictResolver/                     // Новая фича для разрешения конфликтов
        ├── ui/
        │   └── ConflictResolutionDialog.tsx      // Компонент React для диалога
        └── FileConflictResolver.module.css       // Стили для компонента (если нужны)
```

### 3.2. Распределение обязанностей и потока данных

*   **`src/5-features/SaveToDrive/SaveToDrive.tsx`**:
    *   Продолжает отвечать за основной рабочий процесс сохранения файла.
    *   Определяет необходимость отображения диалога конфликтов (управляет `saveToDriveStore.showConflictDialog`).
    *   Передает необходимые данные (`conflictingFileName`, `newFileNameForConflict`, `isSaving` и т.д.) и колбэки для действий (`onResolveConflict`, `onNewFileNameChange`) в новый компонент `ConflictResolutionDialog` через пропсы.

*   **`src/5-features/FileConflictResolver/ui/ConflictResolutionDialog.tsx` (новый компонент)**:
    *   Отвечает исключительно за отображение пользовательского интерфейса диалога разрешения конфликтов.
    *   Получает все необходимые данные и функции-колбэки через пропсы.
    *   Управляет собственной локальной UI-логикой, такой как отображение поля ввода для нового имени (`showRenameInput`).
    *   Вызывает переданные колбэки при взаимодействии пользователя (например, при нажатии кнопок "Перезаписать", "Подтвердить переименование", "Отмена"), передавая выбранное решение.

*   **`src/1-app/Stores/MainStore.ts` / `src/5-features/SaveToDrive/model/SaveToDriveStore.ts`**:
    *   `SaveToDriveStore` (если он есть, или соответствующая часть `MainStore`): Продолжает содержать основную бизнес-логику для сохранения файлов, включая обнаружение конфликтов и методы для их разрешения (`resolveConflict`).
    *   Методы, такие как `setNewFileNameForConflict` и `resolveConflict`, остаются в `SaveToDriveStore`, так как они непосредственно связаны с процессом сохранения.

### 3.3. Принцип работы

1.  Когда `SaveToDriveStore` обнаруживает конфликт имени файла, он устанавливает `showConflictDialog` в `true`.
2.  Компонент `SaveToDrive` рендерит `ConflictResolutionDialog`, передавая ему необходимые пропсы.
3.  `ConflictResolutionDialog` отображает UI, принимает ввод пользователя (например, новое имя файла) и вызывает соответствующие колбэки.
4.  Колбэки, переданные из `SaveToDrive`, в свою очередь, вызывают методы `SaveToDriveStore` (например, `resolveConflict`) для выполнения фактической бизнес-логики.

### 3.4. Преимущества предложенного подхода

*   **Разделение ответственности:** Каждый компонент выполняет четко определенную задачу. `SaveToDrive` занимается сохранением, `ConflictResolutionDialog` — разрешением конфликтов.
*   **Повышенная читаемость и сопровождаемость:** Код становится легче читать, понимать и модифицировать, поскольку компоненты меньше и сфокусированы на одной задаче.
*   **Улучшенная переиспользуемость:** `ConflictResolutionDialog` потенциально может быть использован в других частях приложения, где требуется аналогичный механизм разрешения конфликтов.
*   **Соответствие FSD:** Логика разрешения конфликтов выделяется в отдельную фичу, что способствует более чистой и организованной архитектуре проекта.
*   **Упрощение тестирования:** Отдельные, сфокусированные компоненты легче тестировать изолированно.

## 4. Следующие шаги

1.  Создать файл `src/5-features/FileConflictResolver/ui/ConflictResolutionDialog.tsx`.
2.  Перенести соответствующий JSX и локальное состояние (`showRenameInput`) из `SaveToDrive.tsx` в `ConflictResolutionDialog.tsx`.
3.  Изменить `SaveToDrive.tsx` для импорта и использования нового компонента `ConflictResolutionDialog`, передавая ему необходимые пропсы.
4.  Проверить функциональность, убедившись, что процесс сохранения и разрешение конфликтов работают корректно.
5.  (Необязательно) Если потребуется более сложная логика, специфичная для диалога, рассмотреть возможность создания отдельного MobX стора для `FileConflictResolver`. Однако на текущий момент `SaveToDriveStore` достаточно для управления состоянием, связанным с конфликтом.